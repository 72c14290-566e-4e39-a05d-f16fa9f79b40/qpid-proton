#--
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#++

require 'thread'
require 'set'
require_relative 'listener'

module Qpid::Proton
  # An AMQP container manages a set of {Listener}s and {Connection}s which
  # contain {#Sender} and {#Receiver} links to transfer messages.  Usually, each
  # AMQP client or server process has a single container for all of its
  # connections and links.
  #
  # One or more threads can call {#run}, events generated by all the listeners and
  # connections will be dispatched in the {#run} threads.
  class Container
    private

    # Container driver applies options and adds container context to events
    class ConnectionTask < Qpid::Proton::HandlerDriver
      def initialize container, io, opts, server=false
        super io, opts[:handler]
        transport.set_server if server
        transport.apply opts
        connection.apply opts
        @container = container
      end

      def event
        # Add a container to the event
        e = super()
        e.container = @container if e
        e
      end
    end

    class ListenTask < Listener

      def initialize(io, handler, container)
        super
        env = ENV['PN_TRACE_EVT']
        if env && ["true", "1", "yes", "on"].include?(env.downcase)
          @log_prefix = "[0x#{object_id.to_s(16)}](PN_LISTENER_"
        end
      end

      def process
        unless @closing
          unless @open_dispatched
            dispatch(:on_open);
            @open_dispatched = true
          end
          begin
            return @io.accept, dispatch(:on_accept)
          rescue IO::WaitReadable, Errno::EINTR
          rescue IOError, SystemCallError => e
            close e
          end
        end
        if @closing
          @io.close rescue nil
          @closing = false
          @closed = true
          dispatch(:on_error, @condition) if @condition
          dispatch(:on_close)
        end
      end

      def can_read?() !@closed; end
      def can_write?() false; end
      def finished?() @closed; end

      def dispatch(method, *args)
        STDERR.puts "#{@log_prefix}#{([method[3..-1].upcase]+args).join ', '})" if @log_prefix
        @handler.__send__(method, self, *args) if @handler && @handler.respond_to?(method)
      end
    end

    public

    # Create a new Container
    # @overload initialize(id=nil)
    #   @param id [String] A unique ID for this container, use random UUID if nil.
    #
    # @overload initialize(handler=nil, id=nil)
    #  @param id [String] A unique ID for this container, use random UUID if nil.
    #  @param handler [MessagingHandler] Optional default handler for connections
    #   that do not have their own handler (see {#connect} and {#listen})
    #
    #   *Note*: For multi-threaded code, it is recommended to use a separate
    #   handler instance for each connection, as a shared handler may be called
    #   concurrently.
    #
    def initialize(handler = nil, id = nil)
      # Allow ID as sole argument
      (handler, id = nil, handler.to_str) if (id.nil? && handler.respond_to?(:to_str))
      raise TypeError, "Expected MessagingHandler, got #{handler.class}" if
        handler && !handler.is_a?(Qpid::Proton::Handler::MessagingHandler)

      # TODO aconway 2017-11-08: allow multiple handlers, opts for backwards compat?
      @handler = handler
      @id = ((id && id.to_s) || SecureRandom.uuid).freeze

      # Implementation note:
      #
      # - #run threads take work from @work
      # - Each driver and the Container itself is processed by at most one #run thread at a time
      # - The Container thread does IO.select
      # - nil on the @work queue makes a #run thread exit

      @work = Queue.new
      @work << self             # Let the first #run thread start selecting
      @wake = IO.pipe           # Wakes #run thread in IO.select
      @auto_stop = true         # Exit #run when @active drops to 0

      # Following instance variables protected by lock
      @lock = Mutex.new
      @active = 0               # All active tasks, in @selectable, @work or being processed
      @selectable = Set.new     # Tasks ready to block in IO.select
      @running = 0              # Count of #run threads
      @stopping = false         # #stop called, closing tasks
      @stop_err = nil           # Optional error from #stop
    end

    # @return [String] unique identifier for this container
    attr_reader :id

    # Auto-stop flag.
    #
    # True (the default) means all calls to {#run} will return when the container
    # transitions from active to inactive - all connections and listeners
    # have closed.
    #
    # False means {#run} will not return unless {#stop} is called.
    #
    # @return [Bool] auto-stop state
    attr_accessor :auto_stop

    # Open an AMQP connection.
    #
    # @param url [String, URI] Open a {TCPSocket} to url.host, url.port.
    # url.scheme must be "amqp" or "amqps", url.scheme.nil? is treated as "amqp"
    # url.user, url.password are used as defaults if opts[:user], opts[:password] are nil
    # @option (see Connection#open)
    # @return [Connection] The new AMQP connection
    def connect(url, opts = {})
      url = Qpid::Proton::uri(url)
      opts[:user] ||= url.user
      opts[:password] ||= url.password
      # TODO aconway 2017-10-26: Use SSL for amqps URLs
      connect_io(TCPSocket.new(url.host, url.port), opts)
    end

    # Open an AMQP protocol connection on an existing {IO} object
    # @param io [IO] An existing {IO} object, e.g. a {TCPSocket}
    # @option (see Connection#open)
    def connect_io(io, opts = {})
      cd = connection_driver(io, opts)
      cd.connection.open()
      add(cd)
      cd.connection
    end

    # Listen for incoming AMQP connections
    #
    # @param url [String,URI] Listen on host:port of the AMQP URL
    # @param handler [Listener::Handler] A {Listener::Handler} object that will be called
    # with events for this listener and can generate a new set of options for each one.
    # @return [Listener] The AMQP listener.
    #
    def listen(url, handler=Listener::Handler.new)
      url = Qpid::Proton::uri(url)
      # TODO aconway 2017-11-01: amqps
      listen_io(TCPServer.new(url.host, url.port), handler)
    end

    # Listen for incoming AMQP connections on an existing server socket.
    # @param io A server socket, for example a {TCPServer}
    # @param handler [Listener::Handler] Handler for events from this listener
    #
    def listen_io(io, handler=Listener::Handler.new)
      l = ListenTask.new(io, handler, self)
      add(l)
      l
    end

    # Run the container: wait for IO activity, dispatch events to handlers.
    #
    # More than one thread can call {#run} concurrently, the container will use
    # all the {#run} threads as a thread pool. Calls to
    # {Handler::MessagingHandler} methods are serialized for each connection or
    # listener, even if the container has multiple threads.
    #
    def run
      need_on_start = nil
      @lock.synchronize do
        @running += 1
        need_on_start = !@on_start_called &&  @handler && @handler.respond_to?(:on_start)
        @on_start_called = true
      end
      if need_on_start
        # TODO aconway 2017-10-28: proper synthesized event for on_start
        event = Class.new do
          def initialize(c) @container = c; end
          attr_reader :container
        end.new(self)
        @handler.on_start(event)
      end

      while task = @work.pop
        case task
        when Container
          r, w = [@wake[0]], []
          @lock.synchronize do
            @selectable.each do |s|
              r << s if s.send :can_read?
              w << s if s.send :can_write?
            end
          end
          r, w = IO.select(r, w)
          selected = Set.new(r).merge(w)
          drain_wake if selected.delete?(@wake[0])
          @lock.synchronize do
            if @stopping # close everything
              selected += @selectable
              selected.each { |s| s.close @stop_err }
            end
            @selectable -= selected # Remove selected tasks
          end
          selected.each { |s| @work << s } # Queue up tasks needing #process
          @work << self                    # Allow another thread to select()
        when ConnectionTask then
          task.close @stop_err if @lock.synchronize { @stopping }
          task.process
          rearm task
        when Listener then
          task.close @stop_err if @lock.synchronize { @stopping }
          io, opts = task.process
          add(connection_driver(io, opts, true)) if io
          rearm task
        end
        # TODO aconway 2017-10-26: scheduled tasks, heartbeats
      end
    ensure
      @lock.synchronize do
        @stopping, @stop_err = nil if (@running -= 1).zero? # Last out, reset for next #run
      end
    end

    # Disconnect all listeners and connections without a polite AMQP close sequence.
    # {#stop} returns immediately, calls to {#run} will return when all activity is finished.
    # @param error [Condition] Optional transport/listener error condition
    #
    def stop(error=nil)
      @lock.synchronize do
        @stopping = true
        @stop_err = Condition.make(error)
        check_stop_lh
        # NOTE: @stopping =>
        # - no new run threads can join
        # - no more select calls after next wakeup
        # - once @active == 0, all threads will be stopped with nil
      end
      wake
    end

    private

    def wake; @wake[1].write_nonblock('x') rescue nil; end

    def work_wake(task) @work << task; wake; end

    def drain_wake
      begin
        @wake[0].read_nonblock(256) while true
      rescue Errno::EWOULDBLOCK, Errno::EAGAIN, Errno::EINTR
      end
    end

    def connection_driver(io, opts, server=false)
      opts ||= {}
      opts[:container_id] ||= @id
      opts[:handler] ||= @handler
      ConnectionTask.new(self, io, opts, server)
    end

    def add task
      @lock.synchronize { @active += 1 }
      work_wake task
    end

    def rearm task
      @lock.synchronize do
        if task.finished?
          @active -= 1
          check_stop_lh
        else
          @selectable << task
        end
      end
      wake
    end

    def check_stop_lh
      if @active.zero? && (@auto_stop || @stopping)
        @running.times { @work << nil } # Signal all threads to stop
        true
      end
    end
  end
end
